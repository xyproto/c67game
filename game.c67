export *

import sdl3 as sdl

// SDL_Event is a large union - allocate 256 bytes to be safe
cstruct SDL_Event {
    type as uint32
    padding1 as uint64
    padding2 as uint64
    padding3 as uint64
    padding4 as uint64
    padding5 as uint64
    padding6 as uint64
    padding7 as uint64
    padding8 as uint64
    padding9 as uint64
    padding10 as uint64
    padding11 as uint64
    padding12 as uint64
    padding13 as uint64
    padding14 as uint64
    padding15 as uint64
    padding16 as uint64
    padding17 as uint64
    padding18 as uint64
    padding19 as uint64
    padding20 as uint64
    padding21 as uint64
    padding22 as uint64
    padding23 as uint64
    padding24 as uint64
    padding25 as uint64
    padding26 as uint64
    padding27 as uint64
    padding28 as uint64
    padding29 as uint64
    padding30 as uint64
}

cstruct SDL_FRect {
    x as float32
    y as float32
    w as float32
    h as float32
}



G_WINDOW := 0
G_RENDERER := 0
G_GAMEPAD := 0
G_RUNNING := 1

// Unified input state (combines keyboard + gamepad + d-pad)
G_INPUT_UP := 0
G_INPUT_DOWN := 0
G_INPUT_LEFT := 0
G_INPUT_RIGHT := 0
G_INPUT_ACTION1 := 0
G_INPUT_ACTION2 := 0

// Global rectangle buffer (4 floats = 16 bytes)
// Since C67 stores everything as float64, we use a 4-element list and cast to floats
G_RECT_BUFFER := [0.0, 0.0, 0.0, 0.0]

Init_window = (title, width, height) -> {
    // Initialize SDL3 with video and gamepad support (returns true on success in SDL3)
    sdl_result := sdl.SDL_Init(sdl.SDL_INIT_VIDEO |b sdl.SDL_INIT_GAMEPAD)
    sdl_result or! {
        exitln("Failed to init SDL3")
    }
    
    win := sdl.SDL_CreateWindow(title, width, height, 0)
    win or! {
        exitln("Failed to create window")
    }
    G_WINDOW <- win
    
    rend := sdl.SDL_CreateRenderer(win, 0)
    rend or! {
        exitln("Failed to create renderer")
    }
    G_RENDERER <- rend
    
    // Try to open first gamepad if available
    gamepad := sdl.SDL_OpenGamepad(0)
    gamepad != 0 {
        G_GAMEPAD <- gamepad
        println("Gamepad connected!")
    }
}

Clear_screen = (color) -> {
    red := (color >>b 16) &b 255
    green := (color >>b 8) &b 255
    blue := color &b 255
    sdl.SDL_SetRenderDrawColor(G_RENDERER, red, green, blue, 255)
    sdl.SDL_RenderClear(G_RENDERER)
}

Fill_rect = (x, y, w, h, color) -> {
    red := (color >>b 16) &b 255
    green := (color >>b 8) &b 255
    blue := color &b 255
    sdl.SDL_SetRenderDrawColor(G_RENDERER, red, green, blue, 255)
    
    // TODO: implement rect rendering when ptr[offset] <- value as float32 syntax is fully supported
    // For now, just set the color (which works for clearing)
}

Draw_rect = (x, y, w, h, color) -> {
    red := (color >>b 16) &b 255
    green := (color >>b 8) &b 255
    blue := color &b 255
    sdl.SDL_SetRenderDrawColor(G_RENDERER, red, green, blue, 255)
    
    // TODO: implement rect rendering when ptr[offset] <- value as float32 syntax is fully supported
}

Draw_line = (x1, y1, x2, y2, color) -> {
    red := (color >>b 16) &b 255
    green := (color >>b 8) &b 255
    blue := color &b 255
    sdl.SDL_SetRenderDrawColor(G_RENDERER, red, green, blue, 255)
    sdl.SDL_RenderLine(G_RENDERER, x1, y1, x2, y2)
}

Present = {
    sdl.SDL_RenderPresent(G_RENDERER)
}

Delay = (ms) -> {
    sdl.SDL_Delay(ms)
}

Poll_events = {
    // Reset input state each frame
    G_INPUT_UP <- 0
    G_INPUT_DOWN <- 0
    G_INPUT_LEFT <- 0
    G_INPUT_RIGHT <- 0
    G_INPUT_ACTION1 <- 0
    G_INPUT_ACTION2 <- 0
    
    // Get keyboard state (NULL pointer is OK for SDL_GetKeyboardState)
    keyboard := sdl.SDL_GetKeyboardState(0)
    
    // Only check keyboard if pointer is valid
    keyboard != 0 {
        // SDL_GetKeyboardState returns pointer to byte array, read byte at offset
        // Since ptr[offset] reads 8 bytes, we use ptr <- to write and unsafe reads for bytes
        // For now, just skip keyboard input to avoid the crash
        key_up := 0
        key_down := 0
        key_left := 0
        key_right := 0
        key_w := 0
        key_s := 0
        key_a := 0
        key_d := 0
        key_space := 0
        key_shift := 0
        
        // Combine keyboard inputs
        (key_up != 0 |b key_w != 0) {
            G_INPUT_UP <- 1
        }
        (key_down != 0 |b key_s != 0) {
            G_INPUT_DOWN <- 1
        }
        (key_left != 0 |b key_a != 0) {
            G_INPUT_LEFT <- 1
        }
        (key_right != 0 |b key_d != 0) {
            G_INPUT_RIGHT <- 1
        }
        key_space != 0 {
            G_INPUT_ACTION1 <- 1
        }
        key_shift != 0 {
            G_INPUT_ACTION2 <- 1
        }
    }
    
    // Check gamepad inputs if connected
    G_GAMEPAD != 0 {
        // D-pad
        dpad_up := sdl.SDL_GetGamepadButton(G_GAMEPAD, 12)
        dpad_down := sdl.SDL_GetGamepadButton(G_GAMEPAD, 13)
        dpad_left := sdl.SDL_GetGamepadButton(G_GAMEPAD, 14)
        dpad_right := sdl.SDL_GetGamepadButton(G_GAMEPAD, 15)
        
        // Face buttons (A/B)
        button_south := sdl.SDL_GetGamepadButton(G_GAMEPAD, 0)
        button_east := sdl.SDL_GetGamepadButton(G_GAMEPAD, 1)
        
        dpad_up != 0 {
            G_INPUT_UP <- 1
        }
        dpad_down != 0 {
            G_INPUT_DOWN <- 1
        }
        dpad_left != 0 {
            G_INPUT_LEFT <- 1
        }
        dpad_right != 0 {
            G_INPUT_RIGHT <- 1
        }
        button_south != 0 {
            G_INPUT_ACTION1 <- 1
        }
        button_east != 0 {
            G_INPUT_ACTION2 <- 1
        }
    }
    
    // Process SDL events - simplified for now
    // TODO: properly handle events when ptr[byte_offset] <- value syntax works
    0
}

Running = {
    G_RUNNING
}

// Unified input queries (keyboard + gamepad)
Input_up = {
    G_INPUT_UP
}

Input_down = {
    G_INPUT_DOWN
}

Input_left = {
    G_INPUT_LEFT
}

Input_right = {
    G_INPUT_RIGHT
}

Input_action1 = {
    G_INPUT_ACTION1
}

Input_action2 = {
    G_INPUT_ACTION2
}

// Fullscreen management
Is_fullscreen = {
    flags := sdl.SDL_GetWindowFlags(G_WINDOW)
    (flags &b 1) != 0
}

Toggle_fullscreen = {
    Is_fullscreen() {
        // Exit fullscreen
        sdl.SDL_SetWindowFullscreen(G_WINDOW, 0)
    }
    Is_fullscreen() == 0 {
        // Enter fullscreen
        sdl.SDL_SetWindowFullscreen(G_WINDOW, 1)
    }
}
